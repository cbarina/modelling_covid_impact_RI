---
title: "Analyses for COVID-19 impact on Routine Immunisation in 2021"
author: "Beth Evans and Thibaut Jombart"
date: "30 Nov 2021"
output: 
  html_document:
    code_folding: "show"
    toc: TRUE
    toc_depth: 4
    toc_float: TRUE
    toc_collapse: FALSE
    number_sections: TRUE
    highlight: pygments
    theme: spacelab
params:
  data: "dtp3"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Set-up

## Load packages

```{r, message = FALSE}
library(tidyverse)
library(rio)
library(magrittr)
library(timetk)
library(broom)
library(scales)
library(ggforce)
library(urca)
library(tseries)
library(forecast)
library(data.table)
library(countrycode)
library(here)
library(flextable)
library(webshot)
library(wesanderson)

```

## Load raw data

Import data:

- Coverage data from WUENIC for 2000-2020
- Income group classification from World Bank
- Birth and infant mortality data from United Nations World Population Prospects
  (UN WPP)

```{r}
# Set-up toggle to pull DTP1 and DTP3 data respectively when compiling for the
# appropriate antigen
if (params$data == "dtp1") {
  file_path <- here::here("data", "dtp1_oct.csv")
} else if (params$data == "dtp3") {
  file_path <- here::here("data", "dtp3_oct.csv")
} else {
  msg <- sprintf("Unknown dataset requested: %s", params$data)
  stop(msg)
}

# Impact WUENIC data
data_raw <- file_path %>%
  rio::import(header = TRUE) %>%
  tibble()
data_raw

# Import World Bank classification data
file_path_wb <- here::here("data", "wb_ig.csv")
income <- file_path_wb %>%
  rio::import(header = TRUE) %>%
  tibble()
income

# Import UN WPP data
file_path_unwpp_raw <- here::here("data", "WPP2019_INT_F01_ANNUAL_DEMOGRAPHIC_INDICATORS.csv")

unwpp_raw <- file_path_unwpp_raw %>%
  rio::import(header = TRUE, skip = 16) %>%
  tibble()

unwpp_raw

```

## Set-up output folders

Outputs are stored in two separate folders (in addition to the compiled report,
handled by the *reportfactory*), *outputs/figures/* and *outputs/csv/*. We make
sure these exist.

```{r}
# Make sure output folder exists
fig_folder <- here::here("figures", params$data)
if (!dir.exists(fig_folder)) {
  dir.create(fig_folder, recursive = TRUE)
}

# Make sure output folder exists
csv_folder <- here::here("outputs", "csv", params$data)
if (!dir.exists(csv_folder)) {
  dir.create(csv_folder, recursive = TRUE)
}

```



# Data preparation

Here we prepare the dataset analysed called `x`.

## Data cleaning

Steps taken:

- rename variables 
- reshape data to long vs. wide format
- add categorisation columns (income group, region)
- select relevant columns only 

```{r}

# Clean and reshape 2000-2020 coverage data
data_raw %<>%
  dplyr::rename(region = unicef_region, iso_code = iso3)

data_long <- data_raw %>%
  pivot_longer(-(region:vaccine), names_to = "year", values_to = "coverage")
names(data_long) <- tolower(names(data_long))
data_long

# Join 'income' classification to main dataset
income %<>% 
  filter(datayear == "2020") %>%
  dplyr::rename(iso_code = wb_code) %>%
  dplyr::select(-c(datayear, country, fiscalyear, publicationyear))
income

data_long %<>%
  inner_join(income, by = "iso_code")
data_long

# Clean consolidated projection dataset
x <- data_long %>%
  mutate(coverage = coverage / 100,
         year = as.integer(year),
         income_group = recode_factor(income_group,
                                      "Low income" = "LIC",
                                      "Lower middle income" = "LMIC",
                                      "Upper middle income" = "UMIC",
                                      "High income" = "HIC")        
         ) %>%
  select(region, country, iso_code, income_group, year, coverage) %>%
  arrange(country, year)
x

```


## Data filtering

We remove:

- years prior to 2000
- entries where coverage is NA
- countries without data for the last 21 consecutive years (from 2000 to 2020,
  inclusive)

```{r}

# Filter for data from 2000 onwards (inclusive), remove NAs
x <- x %>%
  filter(year >= 2000, !is.na(coverage))

# Filter for countries with complete data from 2000 to 2020, i.e. 21 data points
complete_countries <- x %>%
  count(iso_code) %>%
  filter(n == 21) %>%
  pull(iso_code)

x %<>%
  filter(iso_code %in% complete_countries)

```


# ARIMA modelling

Here we apply ARIMA to each country using the years 2000-2019 as training set,
and derive a forecast for 2020 with associated confidence intervals. The final
object will be called `res`, and will include these forecasts, the actual values
reported, and the corresponding coverage *deltas*, defined as (% reported - %
expected).

## Model parameters

Model "expected' 2020 coverage based, in the absence of COVID, based on
2000-2019 trends.  ARIMA model uses timeseries data by country to (a) select the
most appropriate model, defined by three parameters (p, d, q) selected as
follows:

- p = number of autoregressive terms - based on minimisation of the AIC
- d = number of non-seasonal differences needed for stationarity - based on conducting KPSS tests
- q = number of lagged forecast errors in the prediction equation - based on minimisation of the AIC

and (b) predict 2020 coverage based on this selected model.


## Fitting models

`auto.arima` requires time series (`ts`) objects, which is essentially a wide
format for coverage data (rows = years, columns = countries)..

```{r}

# Reshape data to timeseries format
ts_df <- x %>%
  filter(year < 2020) %>% 
  select(year, iso_code, coverage) %>%
  pivot_wider(values_from = coverage, names_from = iso_code) %>%
  arrange(year) %>%
  select(-year) %>% 
  ts(start = 2000, freq = 1)

# ARIMA forecast 2020 coverage from 2000-2019 data for all countries
ts_forecasts <- lapply(ts_df, # iterate over all countries
                      function(y)
                        forecast(auto.arima(y, seasonal = FALSE),
                                 h = 1, # forecast 1 year ahead
                                 level = 95 # 95% CIs
                                 ))

# extract forecasts and format output
temp <- lapply(ts_forecasts, as.data.frame)

forecasts <- bind_rows(temp) %>%
  mutate(iso_code = names(temp),
         mean = `Point Forecast`,
         lower_ci = `Lo 95`,
         upper_ci = `Hi 95`) %>%
  tibble() %>%
  select(iso_code, mean, lower_ci, upper_ci)
forecasts

```

Since WUENIC coverage is capped at 99% (i.e., no country can ever report 100%)
we replace any 2020 estimates >99% to 99% coverage; also make sure CI don't go
below 0.

```{r}

forecasts <- forecasts %>%
  mutate(mean = if_else(mean > 0.99, 0.99, mean),
         lower_ci = if_else(lower_ci < 0, 0, lower_ci),
         upper_ci = if_else(upper_ci > 0.99, 0.99, upper_ci),)

```


## Combine ARIMA predictions and 2020 data

Here we add the model prediction to the data, keeping only 2020, and calculate
deltas (coverage values in 2020: % reported - % expected) and associated
confidence intervals.

```{r}

res_all <- forecasts %>%
  left_join(x) %>%
  filter(year == 2020) %>% 
  mutate(delta = coverage - mean,
         lower_delta = coverage - lower_ci,
         upper_delta = coverage - upper_ci,
         confident_95 = (coverage > lower_ci) & (coverage < upper_ci),
         ci_width = upper_ci - lower_ci
         )

```


## Remove unreliable expected coverage estimates

Countries were considered as potential unreliable datapoints based on:

1. Visual inspection of 2000-2019 WUENIC reported coverage showed high
volatility, i.e., fluctuations over a 10-percentage point range in the last
five to 10 years – since this indicates coverage estimates may be unreliable
and uncertain

2. Visual inspection of forecast model fit showed fit dependent on major
increases/ decreases in 2018-2019 coverage – since this indicates exceptional
circumstances (e.g., stockouts, civil war) may have overly weighted forecast
coverage

3. Calculating forecast percentage point improvement in coverage from reported
2019 to forecast 2020 coverage and reviewing countries with forecast +5
percentage point improvements – since such may not be programmatically realistic
(despite model fitting)

Then, WUENIC country-specific documentation was reviewed to confirm whether to
remove countries.

For option (3):

```{r}

# Filter out countries with >5p.p. improvement
res <- res_all %>%
  filter(delta <= 0.05)
res

```

Countries considered as potential unreliable estimated coverage estimates are
detailed with explanations in the Supplementary Materials.


## Remove countries identified as unreliable datapoints

```{r}

# Default is to remove no countries
removed_countries <- NULL

# Removed countries for DTP1
if (params$data == "dtp1") {
  removed_countries <- c("Haiti", "Libya", "Samoa", "Solomon Islands", "Brazil",
                         "Jordan", "Bolivia (Plurinational State of)",
                         "Suriname", "Austria")
}

# Removed countries for DTP3
if (params$data == "dtp3") {
  removed_countries <- c("Haiti", "Libya", "Samoa", "Solomon Islands", "Brazil",
                         "El Salvador", "Jordan",
                         "Venezuela (Bolivarian Republic of)", "Suriname")
}

# Keep track of removed countries
res_removed_countries <- res %>%
  dplyr::filter(country %in% removed_countries)
x_removed_countries <- x %>%
  dplyr::filter(country %in% removed_countries)

# Remove countries from dataset for further analysis
res <- res %>%
  dplyr::filter(!country %in% removed_countries)

```


#### Plot of removed datapoints

```{r, results = "hide", fig.keep = 1, fig.width = 10, fig.height = 10, out.width = "100%"}

# Define color for model
arima_color <- "#ac3973"

# Generate plot
fig_removed_countries <- x_removed_countries %>%
  ggplot(aes(x = year, y = coverage)) +
  theme_bw() +
  geom_point(alpha = 0.8) +
  geom_line(alpha = 0.3) +
  geom_errorbar(data = res_removed_countries,
                aes(ymin = lower_ci, ymax = upper_ci),
                color = arima_color) +
  geom_point(data = res_removed_countries,
             aes(y = mean), shape = 3, color = arima_color) +
  facet_wrap(~ country, scales = "free_y",
             labeller = label_wrap_gen(25)) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1L), 
                     limits = c(NA,1),
                     n.breaks = 5) +
  labs(title = "Countries removed from further analysis - unreliable ARIMA",
       y = "Coverage (%)",
       x = "Year") +
  theme(axis.text.x = element_text(angle=45,hjust = 1, size = 14),
        axis.text.y = element_text(size = 14), 
        strip.text.x = element_text(size = 14), 
        axis.title = element_text(size = 18))

fig_removed_countries

# Save file
ggsave(filename = here::here(fig_folder, "forecast_removed_countries.png"),
       plot = fig_removed_countries, 
       width = 30, height = 30, units = "cm")

```



## Plot and visualise coverage timeseries

This reproduces the figure from the paper using the 4 largest countries as an
example of reported coverage values vs ARIMA model prediction.

```{r, out.width = "100%", fig.width = 10}

# Select countries for inclusion in plot
large_pops <- c("China", "India", "Pakistan", "Nigeria")

x_large <- x %>%
  filter(country %in% large_pops)

res_large <- res %>%
  filter(country %in% large_pops)

# Generate plot
arima_color <- "#ac3973"

fig_large_pops <- ggplot(data = x_large, aes(x = year, y = coverage)) +
  theme_bw() +
  geom_point(alpha = 0.8) +
  geom_line(alpha = 0.3) +
  geom_errorbar(data = res_large, aes(ymin = lower_ci, ymax = upper_ci),
                color = arima_color) +
  geom_point(data = res_large, aes(y = mean), shape = 3, color = arima_color) +
  facet_wrap(~ country, nrow = 1, scales = "free_y",
             labeller = label_wrap_gen(25)) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1L), 
                     limits = c(NA,1),
                     n.breaks = 5) +
  labs(y = "Coverage (%)",
       x = "Year") +
  theme(axis.text.x = element_text(angle=45,hjust = 1, size = 14),
        axis.text.y = element_text(size = 14), 
        strip.text.x = element_text(size = 14), 
        axis.title = element_text(size = 18))
 
fig_large_pops

# Save file 
ggsave(filename = here::here(fig_folder, "forecast_large_pops.png"),
       plot = fig_large_pops, 
       width = 30, height = 10, units = "cm")

```





<br>

# Investigating differences in coverage

In this section we analyse the differences between reported and expected
coverage, in general and across different strata. Note that making a pairwise
t-test between the reported and expected coverage is identical to testing deltas
against the null hypothesis that delta = 0. For simplicity, we do the
latter. Simple ANOVAs will be used when comparing deltas across strata.

## t-test for all countries combined

```{r}

# Conduct t-test
ttest_total <- t.test(res$delta,
                      alternative = "two.sided")
ttest_total

# Create readable output of t-test results
stats_total <- res %>%
  summarise(reported = mean(coverage),
            expected = mean(mean))

tt_total <- tibble(stats_total, broom::tidy(ttest_total))
tt_total

# Save output
write.csv(
  tt_total,
  here::here(csv_folder, "ttest_total.csv"),
  row.names = FALSE)

```

We represent a corresponding scatterplot:

```{r }

fig_overall_results <- res %>% 
  ggplot(aes(x = mean, y = coverage)) +
  #geom_pointrange(alpha = .4, aes(xmin = lower_ci, xmax = upper_ci)) +
  geom_point(alpha = .4, size = 3, aes(color = confident_95)) +
  geom_abline(slope = 1, intercept = 0, linetype = 2) + 
  scale_x_continuous(labels = unit_format(unit = "%", scale = 1e+2)) +
  scale_y_continuous(labels = unit_format(unit = "%", scale = 1e+2)) +
  scale_color_manual(guide = FALSE,
                     values = c(`TRUE` = "black",
                                `FALSE` = "#e63553")) +
  labs(x = "Expected coverage in 2020",
       y = "Actual coverage in 2020") +
  theme_light() +
  theme(plot.title = element_text(face = "bold", size = 20),
        legend.position = "none",
        axis.text = element_text(size = 14),
        axis.title.y = element_text(angle = 90),
        axis.title = element_text(size = 17)
  )

fig_overall_results

# Save file
ggsave(filename = here::here(fig_folder, "overall_results.png"),
       plot = fig_overall_results, 
       width = 15, height = 15, units = "cm")

```


## Analyses by region

Here we perform an ANOVA and associated boxplot by region.

```{r}

# linear model
lm_regions <- lm(delta ~ -1 + region, data = res)

# ANOVA
anova(lm_regions)

# Tests on individual coefficients
ttest_regions <- lm_regions %>%
  summary() %>%
  tidy()

# Create readable output
stats_regions <- res %>%
  group_by(region) %>%
  summarise(reported = mean(coverage),
            expected = mean(mean),
            delta = mean(delta))

tt_regions <- tibble(stats_regions, ttest_regions)
tt_regions

# Save output
write.csv(
  tt_regions,
  here::here(csv_folder, "ttest_region.csv"),
  row.names = FALSE)

```


```{r}
# Generate region box plot
region_pal <- wes_palette("Darjeeling1", 5, type = "discrete")

region <- ggplot(cov_forecast_clean, aes(x = un_region, y = cov_delta_mean, color = un_region)) +
  geom_boxplot(color = region_pal) +
  geom_point(size = 2, position = position_jitter(width = 0.2)) +
  scale_colour_manual(values = region_pal) +
  stat_summary(fun = mean, geom = "point", shape = 4, size = 4, color = region_pal) +
  scale_y_continuous(labels = unit_format(unit = "%", scale = 1e+2)) +
  labs(title = "Region: box plot of change in coverage by UN region",
       x = "Region",
       y = "Change in coverage (reported - expected)",
       colour = "Region") +
  theme_light() +
  theme(plot.title = element_text(face = "bold", size = 20),
        legend.position = "none",
        axis.text = element_text(size = 14),
        axis.title.y = element_text(angle = 90),
        axis.title = element_text(size = 17)
  ) +
  scale_x_discrete(labels = wrap_format(12)) +
  geom_hline(aes(yintercept = 0), linetype = "dashed", colour = "black", size = 1)
region

# Save file
ggsave(filename = here::here(fig_folder, "region_box_plot.png"),
       plot = region, 
       width = 30, height = 15, units = "cm")

```



## ANOVA by income

```{r}

# linear model
lm_incomes <- lm(delta ~ -1 + income_group, data = res)

# ANOVA
anova(lm_incomes)

# Tests on individual coefficients
ttest_incomes <- lm_incomes %>%
  summary() %>%
  tidy()

# Create readable output
stats_incomes <- res %>%
  group_by(income_group) %>%
  summarise(reported = mean(coverage),
            expected = mean(mean),
            delta = mean(delta))

tt_incomes <- tibble(stats_incomes, ttest_incomes)
tt_incomes

# Save output
write.csv(
  tt_incomes,
  here::here(csv_folder, "ttest_incomes.csv"),
  row.names = FALSE)

```



## ANOVA by region and income

We check if deltas still differ by region after accounting for the effect of
income.

```{r}

# linear model
lm_region_incomes <- lm(delta ~ income_group + region, data = res)

# ANOVA
anova(lm_region_incomes)

```






#### Box plot for region


### By income group

```{r}
# Conduct t-test
ttest_income_group <- cov_forecast_clean %>%
  filter(!is.na(actuals_2020)) %>%
  filter(iso_code != "VEN") %>%
  group_by(income_group) %>% 
  do(tidy(t.test(.$actuals_2020, 
                 .$predicts_2020, 
                 alt = "two.sided", 
                 paired = TRUE)))

# Calculate mean WUENIC-reported 2020 coverage and mean ARIMA-modelled 2020 coverage
inc_grp <- cov_forecast_clean %>%
  filter(!is.na(actuals_2020)) %>%
  group_by(income_group) %>%
  dplyr::summarize(mean(actuals_2020), mean(predicts_2020)) %>%
  mutate(vaccine = vax) %>%
  rename(mean_expected = "mean(predicts_2020)",
         mean_reported = "mean(actuals_2020)") %>%
  dplyr::select(income_group, mean_expected, mean_reported)

# Create vector of key outputs from t-test
tt_inc_grp <- ttest_income_group %>%
  dplyr::select(income_group, estimate, p.value, parameter, conf.low, conf.high) %>%
  dplyr::rename(point_estimate = estimate,
                p_value = p.value,
                sample_size = parameter,
                low_bound = conf.low,
                upper_bound = conf.high) %>%
  mutate(sample_size = (sample_size+1)) %>% #since parameter is degrees of freedom not sample size
  left_join(inc_grp, by = "income_group") %>%
  dplyr::select(income_group, sample_size, mean_expected, mean_reported,
                point_estimate, low_bound, upper_bound, p_value)

tt_inc_grp
```

```{r}
# Generate income group box plot
income_dat <- cov_forecast_clean %>%
  filter(iso_code != "VEN")   #remove Venezuela since has no income group

income_pal <- wes_palette("BottleRocket2", 4, type = "discrete")

income_box <- ggplot(income_dat, aes(x = income_group, y = cov_delta_mean, color = income_group)) +
  labs(title = "Income group: box plot of change in coverage by income group",
       x = "Income group",
       y = "Change in coverage (reported - expected)",
       colour = "Income group") +
  scale_y_continuous(labels = unit_format(unit = "%", scale = 1e+2)) +
  geom_boxplot(colour = income_pal) +
  geom_point(size = 2, position = position_jitter(width = 0.2)) +
  scale_colour_manual(values = income_pal) +
  stat_summary(fun = mean, geom = "point", shape = 4, size = 4, color = income_pal) +
  theme_light() +
  theme(plot.title = element_text(face = "bold", size = 20),
        legend.position = "none",
        axis.text = element_text(size = 16),
        axis.title.y = element_text(angle = 90),
        axis.title = element_text(size = 18)) +
  geom_hline(aes(yintercept = 0), linetype = "dashed", colour = "black", size = 1)
income_box

# Save file
ggsave(filename = here::here(fig_folder, "income_box_plot.png"),
       plot = income_box, 
       width = 30, height = 15, units = "cm")

```









## Outputs including missed immunisation quantification

### Calculate missed immunisations

- Import UNWPP data
- Clean UNWPP data to calculate surviving infants in 2020 (target populations for DTP1 and DTP3 vaccination)
- Calculation is: number of births - number of infants that die < age 1

#### Clean UNWPP data
```{r}
unwpp <- unwpp_raw %>% 
  rename(country = "Region, subregion, country or area *",
         country_code = "Country code",
         infant_deaths = "Infant deaths, both sexes combined (under age 1, thousands)",
         births = "Births (thousands)",
         year = "Reference date (1 January - 31 December)") %>%
  filter(Type == "Country/Area",
         year == 2020) %>%
  dplyr::select(country, country_code, infant_deaths, births) %>%
  mutate(births = as.numeric(str_replace_all(births," ", "")),
         infant_deaths = as.numeric(infant_deaths),
         iso_code = countrycode(sourcevar = country_code, origin = "iso3n", destination = "iso3c"),
         surviving_infants = (births-infant_deaths)*1000) %>%
  dplyr::select(iso_code, surviving_infants)
```
#### Calculate missed immunisations
- Multiply coverage delta estimates by surviving infant populations to calculate
additional missed immunisations

```{r}

# Calculate missed immunisations
cov_forecast %<>%
  left_join(unwpp, by = "iso_code") %>%
  mutate(additional_missed = as.integer(surviving_infants * cov_delta_mean * -1),
         additional_missed_low = as.integer(surviving_infants * cov_delta_low * -1),
         additional_missed_high = as.integer(surviving_infants * cov_delta_high * -1),
         expected_missed = as.integer((1 - predicts_2020) * surviving_infants),
         total_missed = as.integer((1 - actuals_2020) * surviving_infants))

```

### Create summary output table including % coverage delta and missed immunisations
```{r}
# Create summary output in cleaned format
summary_output <- cov_forecast %>%
  mutate(actuals_2020 = percent(actuals_2020, accuracy = 0.1),
         predicts_2020 = percent(predicts_2020, accuracy = 0.1),
         cov_delta_mean = percent(cov_delta_mean,accuracy = 0.1)) %>%
  dplyr::select(country, iso_code, region, un_region, income_group,
                predicts_2020, predicts_lower,
                predicts_upper, datapoint_removed, ci_width,
                actuals_2020, cov_delta_mean, cov_delta_low, cov_delta_high,
                confident_95, surviving_infants, total_missed, expected_missed, 
                additional_missed, additional_missed_low, additional_missed_high) %>%
  rename(Country = country,
         "ISO code" = iso_code,
         "UNICEF Region (unused)" = region,
         "UN region" = un_region,
         "Income group" = income_group,
         "ARIMA modelled expected 2020 coverage (mean)" = predicts_2020,
         "ARIMA modelled expected coverage (max 95% CI)" = predicts_lower,
         "ARIMA modelled expected coverage (min 95% CI)" = predicts_upper,
         "ARIMA coverage 95% CI" = ci_width,
         "WUENIC reported 2020 coverage" = actuals_2020,
         "Coverage delta" = cov_delta_mean,
         "Coverage delta (max 95% CI)" = cov_delta_low,
         "Coverage delta (min 95% CI)" = cov_delta_high,
         "95% confident actuals outside expected" = confident_95,
         "Surviving infants" = surviving_infants,
         "Additional missed immunisations (mean)" = additional_missed,
         "Additional missed immunisations (max 95% CI)" = additional_missed_high,
         "Additional missed immunisations (min 95% CI)" = additional_missed_low,
         "Expected missed children" = expected_missed,
         "Total missed immunisations" = total_missed,
         "ARIMA forecast unreliable" = datapoint_removed)

# Save file
write.csv(
  summary_output,
  here::here(csv_folder, "summary_output.csv"),
  row.names = FALSE)
```

### Generate table for manuscript
```{r}
border_style = officer::fp_border(color="black", width=1)

table_output <- summary_output %>%
  filter(`ARIMA forecast unreliable` == FALSE) %>%
  arrange(desc(`Additional missed immunisations (mean)`)) %>%
  head(10) %>%
    mutate(`ARIMA modelled expected 2020 coverage [95% CI]` = 
           paste(`ARIMA modelled expected 2020 coverage (mean)`,
                 " [",percent(as.numeric(`ARIMA modelled expected coverage (max 95% CI)`), 
                              accuracy = 0.1)
                 ,"; ",percent(as.numeric(`ARIMA modelled expected coverage (min 95% CI)`), 
                               accuracy = 0.1),"]",
                 sep = "")) %>%
    rename(`Change in coverage (mean)` = `Coverage delta`) %>%
  select(Country, `ISO code`, `UN region`, `Income group`,
         `ARIMA modelled expected 2020 coverage [95% CI]`, `WUENIC reported 2020 coverage`,
         `Change in coverage (mean)`, `Total missed immunisations`,
         `Additional missed immunisations (mean)`) %>%
  flextable() %>% 
  width(j=c(3, 4, 6, 7), width = 1) %>%
  width(j=1, width = 1.1) %>%
  width(j=2, width = 0.5) %>%
  width(j=5, width = 2) %>%
  width(j=c(8, 9), width = 1.25) %>%
  theme_booktabs() %>%
  bold(bold = TRUE, part = "header") %>%
  vline(part = "all", j = 4, border = border_style) %>%
  vline(part = "all", j = 7, border = border_style)

table_output

save_as_docx("Modelled coverage declines and missed immunisations for 10 countries with greatest absolute increases in missed immunisations" = table_output, path = "../figures/top10_table.docx")
save_as_image(table_output, path = "../figures/top10_table.png", webshot = "webshot")
```


### Summary modelling output

Produce table showing order and fit of all ARIMA models per country

```{r}
# Generate summary table showing ARIMA model fit
order <- output %>%
  filter(plot_key == "Forecast") %>%
  dplyr::select(country, iso_code) %>%
  left_join(model, by = "iso_code") %>%
  as_tibble() %>%
  mutate(mean = percent(as.numeric(mean), accuracy = 0.1),
         lower = percent(as.numeric(lower), accuracy = 0.1),
         upper = percent(as.numeric(upper),accuracy = 0.1),
         method = as.character(method)) %>%
  rename(Country = country,
         "ISO code" = iso_code,
         "ARIMA model fit" = method,
         "Expected 2020 coverage" = mean,
         "Expected: 95% Confidence interval - lower bound" = lower,
         "Expected: 95% Confidence interval - upper bound" = upper)

# Save file
write.csv(
  order,
  here::here(csv_folder, "ARIMA_models.csv"),
  row.names = FALSE)

```
